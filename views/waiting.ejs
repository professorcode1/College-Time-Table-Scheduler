<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        @font-face {
            font-family: hacker_font;
            src: url(Roboto_Mono/RobotoMono-VariableFont_wght.ttf);
        }

        @font-face {
            font-family: terminal;
            src: url(modeseven-font/Modeseven-L3n5.ttf);
        }

        body,
        html {
            height: 100%
        }

        body {
            margin: 0;
        }

        canvas {
            display: block;
            vertical-align: bottom;
        }

        #particles-js {
            position: fixed;
            width: 105%;
            height: 105%;
            background: black
        }

        .text {
            position: absolute;
            /* top: 50%; */
            /* right: 50%; */
            /* transform: translate(50%, -50%); */
            color: white;
            max-width: 90%;
            padding: 2em 3em;
            background: rgba(0, 0, 0, 0.4);
            text-shadow: 0px 0px 2px #131415;
            font-family: terminal;
            letter-spacing: 4px;
        }

        li {
            color: white;
            margin: 2px;
        }
    </style>
    <title>Waiting...</title>
</head>

<body>
    <div style="display: none;" id="userInfo">
        <%=user%>
    </div>
    <div id="particles-js"></div>
    <div class="text" id="main_div">
        <ol id="list">
        </ol>
    </div>
</body>
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"
    integrity="sha384-DkkWv9oJFWLIydBXXjkBWnG1/fuVhw8YPBq37uvvD6WSYRFRqr21eY5Dg9ZhmWdy"
    crossorigin="anonymous"></script>
<script src="graph/lib/graph.js"></script>
<script defer>
    ScheduleGenerator = (user) => {
        console.time("haha");
        const {
            numberOfDays,
            periodsPerDay,
            periods,
            groups,
            rooms,
            professors: profs
        } = user;
        let schedulerGraph = new window.Graph();
        //Initialising Graph Below
        {
            print_message({
                case: "message",
                message: "Initialising::Graph"
            }
            );
            console.log("Initialising graph");
            if (user.numberOfDays == 0 && user.periodsPerDay == 0)
                return console.log("Completed Initialising Graph");
            for (let lpitrt = 1; lpitrt < numberOfDays * periodsPerDay; lpitrt++)
                for (let lpitrt1 = 0; lpitrt1 < lpitrt; lpitrt1++)
                    schedulerGraph.set(lpitrt, lpitrt1);

            for (const room of rooms) {

                for (let lpitrt = 0; lpitrt < room.periodsUsedIn.length; lpitrt++) {
                    for (let lpitrt1 = 0; lpitrt1 < lpitrt; lpitrt1++)
                        schedulerGraph.set(String(room.periodsUsedIn[lpitrt]) + "Period0", String(room.periodsUsedIn[lpitrt1]) + "Period0");


                    for (const roomUnavailabiliy of room.unAvialability)
                        schedulerGraph.set(roomUnavailabiliy, String(room.periodsUsedIn[lpitrt]) + "Period0");
                }
            }
            print_message({
                case: "message",
                message: "Initialising::Rooms Complete"
            }
            );
            console.log("Initialise::Rooms Complete");

            for (const prof of profs) {
                for (let lpitrt = 0; lpitrt < prof.periodsTaken.length; lpitrt++) {
                    for (let lpitrt1 = 0; lpitrt1 < lpitrt; lpitrt1++)
                        schedulerGraph.set(String(prof.periodsTaken[lpitrt]) + "Period0", String(prof.periodsTaken[lpitrt1]) + "Period0");


                    for (const profUnavailabiliy of prof.unAvialability)
                        schedulerGraph.set(profUnavailabiliy, String(prof.periodsTaken[lpitrt]) + "Period0");
                }
            }
            print_message({
                case: "message",
                message: "Initialising::Professors Complete"

            });
            console.log("Initialise::Prof Done");

            for (const group of groups) {
                for (let lpitrt = 0; lpitrt < group.periodsAttended.length; lpitrt++) {
                    for (let lpitrt1 = 0; lpitrt1 < lpitrt; lpitrt1++)
                        schedulerGraph.set(String(group.periodsAttended[lpitrt]) + "Period0", String(group.periodsAttended[lpitrt1]) + "Period0");


                    for (const groupUnavailabiliy of group.unAvialability)
                        schedulerGraph.set(groupUnavailabiliy, String(group.periodsAttended[lpitrt]) + "Period0");
                }
            }
            print_message({
                case: "message",
                message: "Initialising::Groups Complete"

            });
            console.log("Initialise::Group Done");

            for (const period of periods) {
                console.log("Initialise::" + period.periodName);
                print_message({
                    case: "message",
                    message: "Initialising::Period " + period.periodName

                });
                for (let len = 1; len < Number(period.periodLength); len++) {

                    const thisPeriodNode = String(period._id) + "Period" + String(len);

                    for (const node in schedulerGraph._graph[String(period._id) + "Period0"])
                        schedulerGraph.set(node, thisPeriodNode);

                    for (let itrt = Number(period.periodLength) - 1 - len; itrt > 0; itrt--)
                        for (let day = 0; day < numberOfDays; day++)
                            schedulerGraph.set(day * periodsPerDay + periodsPerDay - itrt, thisPeriodNode);

                    for (let itrt = 0; itrt < len; itrt++)
                        for (let day = 0; day < numberOfDays; day++)
                            schedulerGraph.set(day * periodsPerDay + itrt, thisPeriodNode);
                }

                if (period.periodFrequency == 1) {

                    if (period.periodTime != -1) {

                        for (let lpitrt = 0; lpitrt < numberOfDays * periodsPerDay; lpitrt++)
                            if (lpitrt != period.periodTime)
                                schedulerGraph.set(lpitrt, String(period._id) + "Period0");
                    } else if (period.periodAntiTime.length != 0) {

                        for (const antiTime of period.periodAntiTime)
                            for (let perLen = 0; perLen < period.periodLength; perLen++)
                                if (Number(antiTime) + perLen < numberOfDays * periodsPerDay)
                                    schedulerGraph.set(Number(antiTime) + perLen, String(period._id) + "Period" + String(perLen));
                    }
                }


                for (let itrt = Number(period.periodLength) - 1; itrt > 0; itrt--)
                    for (let day = 0; day < numberOfDays; day++)
                        schedulerGraph.set(day * periodsPerDay + periodsPerDay - itrt, String(period._id) + "Period0");

                for (let len = 1; len < Number(period.periodLength); len++)
                    for (let len1 = 0; len1 < len; len1++)
                        schedulerGraph.set(String(period._id) + "Period" + String(len), String(period._id) + "Period" + String(len1));
            }
            let hlprGraph = schedulerGraph.copy();
            schedulerGraph = new window.Graph();

            for (let i = 0; i < numberOfDays * periodsPerDay; i++)
                for (let j = 0; j < i; j++)
                    schedulerGraph.set(i, j);

            for (const period of periods)
                for (let freq = 0; freq < Number(period.periodFrequency); freq++)
                    for (let len = 0; len < Number(period.periodLength); len++) {
                        const thisPeriodNode = String(period._id) + "Period" + String(len) + "Freq" + String(freq);

                        //a corner case someone can use to break the application is to make 1 period for a university with 1 day and 1 period per day
                        //thus creating a graph in which case neither the nodes will come into existence since the graph is intialised via edges
                        //to avoide that edge case i.e. any graph with disjoint nodes,all nodes are first attached then detacched from 0,to create the nodes
                        schedulerGraph.set(0, thisPeriodNode);
                        schedulerGraph.del(0, thisPeriodNode);

                        for (let freq1 = 0; freq1 < freq; freq1++)
                            for (let len1 = 0; len1 < Number(period.periodLength); len1++)
                                schedulerGraph.set(thisPeriodNode, String(period._id) + "Period" + String(len1) + "Freq" + String(freq1))

                        for (const neighborNode in hlprGraph.adj(String(period._id) + "Period" + String(len)))
                            if (String(neighborNode).length > 24) {
                                let neighborPeriod = periods.find(periodItrt => String(periodItrt._id) == neighborNode.slice(0, 24));
                                for (let freq1 = 0; freq1 < Number(neighborPeriod.periodFrequency); freq1++)
                                    schedulerGraph.set(thisPeriodNode, neighborNode + "Freq" + String(freq1));
                            } else
                                schedulerGraph.set(thisPeriodNode, neighborNode);

                    }

            //Checking if time table is possible
            let abort = false;
            for (const node in schedulerGraph._graph) {
                let inConflict = true;
                for (let periodNumber = 0; periodNumber < numberOfDays * periodsPerDay; periodNumber++)
                    inConflict = inConflict && schedulerGraph.has(node, periodNumber);
                if (inConflict) {
                    periods.find(period => String(period._id) == nodeString.slice(0, 24));
                    console.log("WARNING:The period " + period.periodName + " causing impossible time table config.");
                    print_message({
                        case: "emit",
                        emit: {
                            case: "warning",
                            message: "WARNING:The period " + period.periodName + " causing impossible time table config."
                        }
                    });

                }
            }
            if (abort)
                return {
                    case: "emit",
                    emit: {
                        case: "abort"
                    }
                };
        }

        print_message({
            case: "Initalisation_Success",
            message: "Initialisation::Complete"
        });
        console.log("Initialisation Complete");
        //Calling the ant-colony algorithm in web-assembly complied down from c++
        {
            var instance = new Module.ant_colony(periodsPerDay, numberOfDays, periods.length, schedulerGraph._vertices.length - (periodsPerDay * numberOfDays));
            for (const period of periods)
                instance.add_lecture(String(period._id), period.periodLength, period.periodFrequency);
            for (const node of schedulerGraph._vertices){
                if(node.length > 24)
                    console.log(node,periods.find(period=>String(period._id) == String(node).substr(0,24)).periodName);
                console.log(schedulerGraph._graph[node]);
                for (const nodeNeighbor in schedulerGraph._graph[node]) {
                    instance.add_edge(String(node), String(nodeNeighbor));
                }
            }
            console.log("got here");
            //instance.print_all_periods();
            console.log("all done");
            instance.initiate_coloring();
            console.timeEnd("haha");
        }
    };
    print_message = (message) => {
        switch (message.case) {
            case "message":
                initialising(message.message);
                break;
            case "Initalisation_Success":
                Initalisation_Success(message.message);
                window.scrollTo(0, document.body.scrollHeight);
                break;
            case "warning":
                warning(message.message);
                break;
            case "abort":
                abort(message.message);
                break;
            case "algorithm_update":
                updateCounters(message);
                break;
            case "complete":
                complete();
                break;
            case "failure":
                failure();
                break;
            default:
                console.log(message);
                break;
        }
    };
    function algorithm_update(val1, val2) {
        console.log(val1, val2);
        print_message({
            case: "algorithm_update",
            generation: val1,
            conflicts: val2
        });
    }
    function failure() {
        var greenPart = document.createElement("h1");
        greenPart.setAttribute("style", "color:yellow");
        greenPart.appendChild(document.createTextNode("FAILURE::The algorithm has failed. You can see the best schedule it has generated, but it will have errors."));
        document.getElementById("main_div").appendChild(greenPart);
        complete();
    }
    function complete() {
        document.getElementById("main_div").appendChild(document.createElement("br"));
        var h3 = document.createElement("h3");
        var a = document.createElement("a");
        a.setAttribute("href", "/viewMySchedule");
        a.innerHTML = " here ";
        h3.appendChild(document.createTextNode("Click "));
        h3.appendChild(a);
        h3.appendChild(document.createTextNode(" to redirect to your schedule"));
        document.getElementById("main_div").appendChild(h3);
        window.scrollTo(0, document.body.scrollHeight);
    }
    function updateCounters(params) {
        document.getElementById("generationCounter").innerHTML = params.generation;
        document.getElementById("conflictCounter").innerHTML = params.conflicts;
        //window.scrollTo(0, document.body.scrollHeight);
    }
    function abort(message) {
        var ul = document.getElementById("list");
        var li = document.createElement("li");
        var greenPart = document.createElement("h1");
        greenPart.setAttribute("style", "color:red");
        greenPart.appendChild(document.createTextNode("ABORTING::Fix all period/s throwing warning to proceed with generation"));
        li.appendChild(greenPart);
        ul.appendChild(li);
        window.scrollTo(0, document.body.scrollHeight);
    }
    function warning(message) {
        var ul = document.getElementById("list");
        var li = document.createElement("li");
        var greenPart = document.createElement("h2");
        greenPart.setAttribute("style", "color:white");
        greenPart.appendChild(document.createTextNode(message));
        li.appendChild(greenPart);
        ul.appendChild(li);
        window.scrollTo(0, document.body.scrollHeight);
    }
    function Initalisation_Success(message) {
        var ul = document.getElementById("list");
        var li = document.createElement("li");
        var greenPart = document.createElement("h3");
        greenPart.setAttribute("style", "color:rgb(0,255,122)");
        greenPart.appendChild(document.createTextNode(message));
        li.appendChild(greenPart);
        ul.appendChild(li);
        var mainDiv = document.getElementById("main_div");
        var updateCounter = document.createElement("h1");
        var generationCounter = document.createElement("span");
        generationCounter.setAttribute("id", "generationCounter");
        var conflictCounter = document.createElement("span");
        conflictCounter.setAttribute("id", "conflictCounter");
        updateCounter.appendChild(document.createTextNode("Generation::"));
        updateCounter.appendChild(generationCounter);
        updateCounter.appendChild(document.createElement("br"));
        updateCounter.appendChild(document.createTextNode("Conflict Counter::"));
        updateCounter.appendChild(conflictCounter);
        mainDiv.appendChild(updateCounter);
        window.scrollTo(0, document.body.scrollHeight);
    }
    function initialising(message) {
        var ul = document.getElementById("list");
        var li = document.createElement("li");
        var greenPart = document.createElement("span");
        greenPart.setAttribute("style", "color:" + neonGreen);
        greenPart.appendChild(document.createTextNode(message.substr(0, 12)));
        var orangePart = document.createElement("span");
        orangePart.setAttribute("style", "color:" + neonOrange);
        orangePart.appendChild(document.createTextNode(message.substr(14, message.length - 1)));
        li.appendChild(greenPart);
        li.appendChild(document.createTextNode("::"));
        li.appendChild(orangePart);
        ul.appendChild(li);
        window.scrollTo(0, document.body.scrollHeight);
    }
    const user = JSON.parse(document.getElementById("userInfo").innerHTML);
    const neonGreen = "#39FF14";
    const neonOrange = "#FF6700"
    var Module = {
        onRuntimeInitialized: function () {
            ScheduleGenerator(user);
        }
    };
</script>
<script src="particles.js-master/particles.js">
</script>
<script src="/particles.js-master/demo/js/app.js">
</script>
<script src="ant-colonoy-webambly/ant_colony.js"></script>

</html>